---
title: "Compositional Data Analysis"
date: "`r Sys.Date()`"
output:
  html_document:
    toc: true
    number_sections: true
    code_folding: hide
---

# Introduction

This is where you can write an introduction to your document.

Install the required packages:

```{r eval=TRUE, include=FALSE}
if (!require(rmarkdown)) {
  install.packages("rmarkdown")
}

if (!require(targets)) {
  install.packages("targets")
}

if (!require(visNetwork)) {
  install.packages("visNetwork")
}
```

# Data overview

### Questions:

- [] In the KL15_xrf data, what is the difference between the Area estimates and the DArea? (it seems Area is used trough the analysis)

## ODP

This is the data from the Ocean Drilling Program close to Cyprus. Data contains several Cores, an age model and XRF data. XRF data is a proxy for the chemical composition of the sediment. 

The analysis is done with Ti.AL as a proxy for wetness (?). The time series looks as follows
  
  ```{r, eval=TRUE}
  graph_ts_200ka(display = TRUE, datasets = c("data_odp_967_22", "data_odp721_722_terr", "data_odp_709", "data_icdp_chb", "data_kl09", "data_kl11", "data_kl15", "data_lake_tana"), index = 1)
  ```

  ToDo: It would be more  informative to have point data instead of polygons.

## CHB 14

## KL 15

In the XRF data we have the following variables:

```{r, eval=TRUE}
data <- tar_read(data_kl15)
colnames(data)
```

We want to analyse the Area minerals together with a time component, which gives us a Compositional Time Series (CTS).

```{r, eval=TRUE}
data_select <- data[, c("depth", "age", "Br_Area", "Rb_Area", "Sr_Area", "Zr_Area", "Ru_Area", "Rh_Area", "Mg_Area",
 "Al_Area", "Si_Area", "S_Area", "K_Area", "Ca_Area", "Ti_Area", "Fe_Area")]

# for compositional data, we are interested in the sum of all components
data_select$aggregate <- rowSums(data_select[3:ncol(data_select)])
summary(data_select)
```

The compositional data does not sum up to a constant value. In fact the spread of its sum is rather big.



A first look of the data in KL_15_XRF_tuned:

```{r, eval=TRUE}
# we want to read them in R
data_KL15 <- read.table("data/Africa_NE_200/data/data_KL15_XRF_tuned.txt", header = TRUE, sep = "\t")

# summarise all attributes of our data
summary(data_KL15)

```


For the **correlation** analysis the following datasets are used:

- script_read_data_KL15_XRF

```{r, eval=TRUE}
# we want to read them in R
data_KL15 <- read.table("data/Africa_NE_200/data/data_KL15_XRF.txt", header = TRUE, sep = "\t")

# summarise all attributes of our data
summary(data_KL15)

```



```{r, eval=TRUE}
data_kl15_agem <- read.table("data/Africa_NE_200/data/data_KL15-2_smooth_spline_ages.txt", header = TRUE, sep = "\t")

summary(data_kl15_agem)

```

This appears to be confidence intervals for the age data. "accrate" is the accumulation rate, which indicates the speed of sedimentation.

We also need the data with "quality flags"

```{r, eval=TRUE}
data_kl15_qf <- read.table("data/Africa_NE_200/data/data_KL15_qf.txt", header = TRUE, sep = "\t")

summary(data_kl15_qf)

```




- script_read_data_KL15_orbitalforcing
- script_read_data_KL15_odp967
- script_read_data_KL15_odp722
- script_read_data_KL15_odp721_722
- script_readco2_age
- script_read_data_KL15_CHB_K_RRM_MHT500



# Data Analysis

read the data:
TODO: write pipeline to avoid loading the data all the time

```{r, eval=TRUE, include=FALSE}
# run the read_data_200kyr_all.R script
source("scripts/read_data_200kyr_all.r")
```

## DA Functions

```{r, eval=TRUE, include=FALSE}
graph_ts_200ka <- function(display = TRUE, datasets = c("data_odp_967_22", "data_odp721_722_terr", "data_odp_709", "data_icdp_chb", "data_kl09", "data_kl11", "data_kl15", "data_lake_tana"), index = 1) {
    # with targets we can use read_target to load the data
    d <- get(datasets[index])

    #*******************************200ka Plot of wentness index*************************************
    # Create the plot
    if (!display) {
      png(filename = paste0("graphs/200ka_polygonplot", datasets[index],".png"))
    }

    yt <- d[,2] # your time series y values
    xt <- d[,1] # your time series age values

    # Assuming d is a matrix with two columns
    mean_yt <- mean(d[!is.na(d[,2]), 2], na.rm = TRUE)
    std_dev <- sd(d[!is.na(d[,2]), 2], na.rm = TRUE)

    # Define ylim based on 3-sigma range
    y_min <- mean_yt - 5 * std_dev
    y_max <- mean_yt + 5 * std_dev
    
    #***************************Plotting the graph********************************
    plot(xt, yt, type = "n", xlab = "", ylab = "", xlim = range(xt), ylim = range(yt), main = paste0("200ka Plot of ", datasets[index]))

    # Create the filled areas
    # age matrix
    fill_x <- c(xt, rev(xt))
    # Terrigenous matrix
    fill_y <- c(yt, rep(mean_yt, length(yt)))
    fill_y[yt < mean_yt] <- mean_yt
    fill_y[1] <- mean_yt
    fill_y[length(fill_y)] <- mean_yt
    color_rgb <- col2rgb('#D95319') / 255
    polygon(fill_x, fill_y, col = rgb(color_rgb[1], color_rgb[2], color_rgb[3], alpha = 0.1), border = NA)

    fill_y2 <- c(yt, rep(mean_yt, length(yt)))
    fill_y2[yt > mean_yt] <- mean_yt
    fill_y2[1] <- mean_yt
    fill_y2[length(fill_y2)] <- mean_yt
    color_rgb <- col2rgb('#0072BD') / 255
    polygon(fill_x, fill_y2, col = rgb(color_rgb[1], color_rgb[2], color_rgb[3], alpha = 0.1), border = NA)

    if (!display) {
        # Close the graphics device
        dev.off()
        return()
    }
    
    # #*******************alternative ggplot graph********************************
    # library(ggplot2)

    # # Assuming d is a data frame with two columns
    # mean_val <- mean(d[!is.na(d[,2]), 2], na.rm = TRUE)
    # std_dev <- sd(d[!is.na(d[,2]), 2], na.rm = TRUE)

    # # Define ylim based on 3-sigma range
    # y_min <- mean_val - 5 * std_dev
    # y_max <- mean_val + 5 * std_dev

    # # Create a data frame for the filled areas
    # fill_pos_data <- data.frame(x = c(d[,1], rev(d[,1])), 
    #                         y = c(d[,2], rep(mean_val, nrow(d))))
    # # negative values are replaced with the mean value
    # fill_pos_data$y[fill_data$y < mean_val] <- mean_val

    # # Create a data frame for the filled areas
    # fill_neg_data <- data.frame(x = c(d[,1], rev(d[,1])), 
    #                         y = c(d[,2], rep(mean_val, nrow(d))))
    # # positive values are replaced with the mean value
    # fill_neg_data$y[fill_data$y >= mean_val] <- mean_val


    # # Create the plot
    # p <- ggplot(d, aes(x = yt, y = xt)) +
    # geom_line() +
    # geom_polygon(data = fill_pos_data, aes(x = x, y = y), 
    #             fill = rgb(217/255, 83/255, 25/255, alpha = 0.9), 
    #             color = NA) +
    # geom_polygon(data = fill_neg_data, aes(x = x, y = y), 
    #             fill = rgb(173/255, 216/255, 230/255, alpha = 0.9), 
    #             color = NA) +
    # ylim(y_min, y_max) +
    # theme_minimal() +
    # labs(x = "Time (kyrs BP)", y = "", title = paste0("200ka Plot of Wentness Index of ", datasets[1]))

    # ggsave(filename = paste0("200ka_plot_",datasets[index],".png"), plot = p, path = "graphs/", width = 10, height = 6, dpi = 300)
}

```

### spearman cross correlation analysis

The first step is to reproduce the cross correlation analysis from the paper (especially figure 3).





# Convert Matlab files and reproduce Paper graphs


## Read the files

The following reads data objects from matlab files.

```{r, eval=FALSE}
# Install the R.matlab package if it's not already installed
if (!require(R.matlab)) {
  install.packages("R.matlab")
}

# Load the R.matlab package
library(R.matlab)

# Use the readMat() function to read a .mat file
data <- readMat("data/Africa_NE_200/data_pentagramm_5_1200_025kyr_XCorr.mat")
```

# targets

Visualize the status of the targets pipeline:

```{r, eval=TRUE}
tar_visnetwork()
```